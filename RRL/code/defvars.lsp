;;; -*- Mode: LISP; Syntax: Common-lisp; Package: RRL; Base: 10; -*-

#-franz (in-package "USER")

;; all global variables used by RRL are defvar-ed here. 

(defvar $abstract-proof t)
(defvar $ac nil)
(defvar $aclrpo nil)
(defvar $add-crit-rule nil)  ; from order.l
(defvar $add_time nil)
(defvar $akb_flag nil)
(defvar $ans-rule nil)
(defvar $anspred nil)
(defvar $associative nil)
(defvar $auto-sugg nil)
(defvar $aux-rset nil)
(defvar $avoid-rules nil) ; from normalize.l
(defvar $begin-time 0)
(defvar $block_time nil)
(defvar $blocking-on nil)
(defvar $bool-ops '(hint false true eq badtyped and & *&* xor not -> equ or all exist =)) 
(defvar $brt_time nil)
(defvar $build-rules nil)
(defvar $case-cond t)
(defvar $case-bool t)
(defvar $case-split-terms nil)
(defvar $character-rules nil)
(defvar $check-symmetry nil)
(defvar $ckb_flag nil)
(defvar $combination nil) ; from diophantine.l
(defvar $commutative nil)
(defvar $complete-ops nil)
(defvar $condi-dominate 1)
(defvar $condi-dominate-rules nil)
(defvar $confluent nil)
(defvar $cons-of-ts nil)
(defvar $constructors nil)
(defvar $cover-auto-level 2)
(defvar $cover-sets nil)
(defvar $crit-with-str nil)
(defvar $cycle-op-rules nil)
(defvar $cycle-rule nil)
(defvar $deep-condi 3)
(defvar $def-domains nil)
(defvar $defaults nil)
(defvar $defin-depend nil)
(defvar $del-eqns nil)
(defvar $del-rule-nums nil)
(defvar $del-rules nil)
(defvar $del_rule_str nil)
(defvar $detachment-ops nil)
(defvar $divisible nil)
(defvar $drop-pres nil)
(defvar $eq-arity nil)
(defvar $eq-length nil) 
(defvar $eqn-set nil)
(defvar $eqop_list nil)
(defvar $ex1 nil)
(defvar $ex2 nil)
(defvar $f-weights nil)
(defvar $failed-eqns nil)
(defvar $false-rhs nil)
(defvar $false-term '(false))
(defvar $falsed-pre nil)
(defvar $fast-match nil)
(defvar $first-induc-op nil)
(defvar $fopc-lrpo nil)
(defvar $free-constructors nil)
(defvar $fri-ops '(cond hint case induc))
(defvar $func-name nil)
(defvar $gene t)
(defvar $gene-num nil)
(defvar $glob_prec nil)
(defvar $goal-reduce nil)
(defvar $goal-set nil)
(defvar $goal-size 40)
(defvar $good-symmetry-terms nil)
(defvar $grammar nil)
(defvar $guest-eqn nil)
(defvar $helpfile nil) ; from toplevel.l
(defvar $history nil)
(defvar $history1 nil)
(defvar $idem nil)
(defvar $immediate nil)
(defvar $in-fopc nil)
(defvar $in-port nil)
(defvar $induc nil)
(defvar $induc-eqns nil)
(defvar $induc-terms nil) ; from coverrule.l
(defvar $induc-vars nil)
(defvar $instance-subst-size 5)
(defvar $instant nil)
(defvar $instant-seeds nil)
(defvar $inter-range nil) ; from match.l
(defvar $invalid-rules nil)
(defvar $irredu-num 0)
(defvar $last-soln nil)
(defvar $log-port nil)
(defvar $lrpo nil)
(defvar $manual-history-frequency nil)
(defvar $manual-history-number nil)
(defvar $many-args 4)
(defvar $mark_rule_str nil)
(defvar $max-arity nil)
(defvar $max-history nil)
(defvar $more-break nil)
(defvar $multi-term-induc t)
(defvar $narrow nil)
(defvar $ncritpr nil)
(defvar $new-ac nil)
(defvar $newop-first nil)
(defvar $newop-terms nil)
(defvar $newops nil)
(defvar $newrule-max nil)
(defvar $newrule-num nil)
(defvar $no-history nil)
(defvar $no-rule-del nil)
(defvar $non-comm-cover-sets nil)
(defvar $norm_str nil)
(defvar $norm_time nil)
(defvar $nrules nil)
(defvar $num-trans 0)
(defvar $num-type nil)
(defvar $nusereqn nil)
(defvar $one-way nil)
(defvar $op_goal_rules nil)
(defvar $op_rules nil)
(defvar $operlist nil)
(defvar $ord_time nil)
(defvar $order-help nil)
(defvar $orderhelp nil)
(defvar $ordering nil)
(defvar $over-rewrite nil)
(defvar $p-commut-rules nil) ; from commutative.l
(defvar $pair-set nil)
(defvar $paramodulate nil)
(defvar $pick-rule-str nil)
(defvar $poly-homo-rules nil)
(defvar $polynomial nil)
(defvar $possi-num 0)
(defvar $post-ass-list nil)
(defvar $post-ass-set nil)
(defvar $post-bound nil)
(defvar $post-max nil)
(defvar $post-posi nil)
(defvar $post-set nil)
(defvar $pre-first nil)
(defvar $premises-set nil)
(defvar $prime-acu nil)
(defvar $proc_time nil)
(defvar $prove-eqn nil)
(defvar $prove-method nil)
(defvar $quasis nil)
(defvar $reduce-bound nil)
(defvar $reduce-right nil)
(defvar $reduce-system nil)
(defvar $reduce-times nil)
(defvar $reduce_time nil)
(defvar $reduced-premises nil)
(defvar $resume-rule nil)
(defvar $rl-first nil)
(defvar $rule-names nil)
(defvar $rule-set nil)
(defvar $rule-size nil)
(defvar $runtime-max nil)
(defvar $save-in-port nil)
(defvar $separators nil)
(defvar $set_pred nil)
(defvar $small-depth nil)
(defvar $st_list nil)
(defvar $step-deep 5)
(defvar $strong-type nil)
(defvar $subs nil) ; from polynomial.l
(defvar $subs2 nil)
(defvar $succ-eqns nil)
(defvar $sufficient nil)
(defvar $support nil)
(defvar $sym-arg-positions nil)
(defvar $symbnum nil)
(defvar $symmetry-check nil)
(defvar $symmetry-dels nil)
(defvar $symmetry-terms nil)
(defvar $test nil)
(defvar $testset nil)
(defvar $time-when-last-call 0)
(defvar $trace-proof nil)
(defvar $trace_flag 2)
(defvar $translist nil)
(defvar $true-term '(true))
(defvar $try nil)  ; from consistency.l
(defvar $type-constructors nil)
(defvar $type-rela nil)
(defvar $type-testset nil)
(defvar $unblocked nil)
(defvar $unif_time 0)
(defvar $used-rule-nums nil)
(defvar $user-assistance 1) ;; as if $user-assistance doesn't exist.
(defvar $var-premises nil)
(defvar $var-type-list nil)
(defvar $witness-eqn nil)
(defvar $xnx 5)
(defvar *empty-sub* t)
(defvar *rrl-package* (find-package "USER"))
(defvar *rrl-readtable*   (copy-readtable nil))
(defvar *starting-cl-readtable* *readtable*)
(defvar l__2 nil)  ; from output.l
(defvar l__3 nil)
(defvar l__ctr nil) 
(defvar num-trans 0)
(defvar piport (make-synonym-stream '*standard-input*))
(defvar poport (make-synonym-stream '*standard-output*))
(defvar sharp-backslash-end nil)
(defvar user-top-level nil)
(defvar v_binds nil)


