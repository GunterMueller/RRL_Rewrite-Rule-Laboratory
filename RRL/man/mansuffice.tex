\chapter{Illustration of sufficient completeness checking} 
\normalsize 
\rm 
This example illustrates the {\em
suffice} command which can be used to check whether a function is
completely defined on a domain generated by a set of constructors.
Relations on values generated by the constructors are allowed insofar
as they can be specified using equations.  If a function is not
completely defined, RRL generates tuples of arguments for which the
function is not defined thus aiding the user. In the example below,
the domain is integers being generated by $0$, $s$ (successor), and
$p$ (predecessor), and addition ($+$) is being defined on them. In the
first case, RRL finds addition to be not defined on negative integers.
In the second case, if another relation is specified on constructors,
then $+$ turns out to be completely defined. The test sets generated
for both the cases are also illustrated which exhibit some details of
the test set method.

In order to check whether functions in an axiomatization are completely
defined, the following steps may be followed:
\begin{enumerate}
\item Give an axiomatization as input.
\item Generate a complete system from the axiomatization.
\item Invoke {\em suffice} and when asked for constructors, give
the constructors generating the domain.
\end{enumerate}
The {\em suffice} command can also be invoked on a rewriting system
that is not complete; in that case, RRL may declare a completely
defined function to be not complete.

\small
\tt
\begin{verbatim}
Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> add
Type your equations, enter a ']' when done.
[0: num]
[s: num -> num]
[+: num, num -> num]
x + 0 == x
x + s(y) == s(x + y)
[p: num -> num]
p(s(x)) == x
]

New operators have the arities:
      p: num -> num
      0: -> num
      +: num, num -> num
      s: num -> num

New constant set is: { 0 }
Equations read in are:
 1. (x + 0) == x  [user, 1]
 2. (x + s(y)) == s((x + y))  [user, 2]
 3. p(s(x)) == x  [user, 3]

Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> kb
----- Step 1 -----
Adding rule:   [1] (x + 0) ---> x  [user, 1]

Trying to orient equation: 
  (x + s(y)) == s((x + y))  [user, 2]
  To prove:  (x + s(y))  >  s((x + y))
        or:  (x + s(y))  <  s((x + y))
  Here are some precedence suggestions:
       1.  + > s                     2.  s > +
Either type a list of numbers or
Type Abort, Display, Drop, Equiv, LR, MakeEq, Operator, Postpone, Quit, RL,
     Status, Superpose, Twoway, Undo or Help.
RRL>KB> 1
----- Step 2 -----
Adding rule:   [2] (x + s(y)) ---> s((x + y))  [user, 2]
Adding rule:   [3] p(s(x)) ---> x  [user, 3]
Computing critical pairs with: 
    [3] p(s(x)) ---> x  [user, 3]
Computing critical pairs with: 
    [1] (x + 0) ---> x  [user, 1]
Computing critical pairs with: 
    [2] (x + s(y)) ---> s((x + y))  [user, 2]

Your system is canonical.
  [1] (x + 0) ---> x  [user, 1]
  [2] (x + s(y)) ---> s((x + y))  [user, 2]
  [3] p(s(x)) ---> x  [user, 3]
  ... ...
Total time (including 'undo' action)   = 0.33 sec

Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> suffice
Note: Constructors for Type 'num' is empty.
Type operators you wish to be constructor: 0 s p
No construcotrs for that type. Stop.

Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> operator
Type order, rulesize, display, constructor, commutative, acoperator, 
     transitive, divisible, equivalence, precedence, quit, status, weight, 
     help --> constructor
Type operators you wish to be constructors: 0 s p
Is 's' a free constructor ? (y,n,yes,no) n

Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> suffice
The system has the following constructors:
     Type 'num': { 0, s, p }

Specification of '+' is not completely defined.
Following left hand sides of rules are proposed: 
    (x + p(p(x1))) ---> something
    (x + p(0)) ---> something
Processor time used      =  0.09999999999999998 sec

Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> add
Type your equations, enter a ']' when done.
s(p(x)) == x
]
Equations read in are:
 1. s(p(x)) == x  [user, 4]

Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> kb
----- Step 3 -----
Adding rule:   [4] s(p(x)) ---> x  [user, 4]
Computing critical pairs with: 
    [4] s(p(x)) ---> x  [user, 4]
Adding rule:   [5] s((x + p(x1))) ---> (x + x1)  [4, 2]
Computing critical pairs with: 
    [5] s((x + p(x1))) ---> (x + x1)  [4, 2]
Adding rule:   [6] (x + p(x1)) ---> p((x + x1))  [5, 3]
  Deleting rule:  [5] s((x + p(x1))) ---> (x + x1)  [4, 2]
Computing critical pairs with: 
    [6] (x + p(x1)) ---> p((x + x1))  [5, 3]

Your system is canonical.
  [1] (x + 0) ---> x  [user, 1]
  [2] (x + s(y)) ---> s((x + y))  [user, 2]
  [3] p(s(x)) ---> x  [user, 3]
  [4] s(p(x)) ---> x  [user, 4]
  [6] (x + p(x1)) ---> p((x + x1))  [5, 3]
  ... ...
Total time (including 'undo' action)   = 0.43 sec

Type Add, Akb, Auto, Break, Clean, Delete, Grammar, History, Init, Kb, List,
     Load, Log, Makerule, Narrow, Norm, Option, Operator, Prove, Quit, Read,
     Refute, Save, Statics, Suffice, Undo, Unlog, Write or Help.
RRL-> suffice
The system has the following constructors:
     Type 'num': { 0, s, p }
Specification of '+' is completely defined.
\end{verbatim}
\rm
\normalsize
